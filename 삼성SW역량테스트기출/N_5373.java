//백준 5373번(큐빙)
//시뮬레이션 문제
/*문제
루빅스 큐브는 삼차원 퍼즐이다. 보통 루빅스 큐브는 3×3×3개의 작은 정육면체로 이루어져 있다. 퍼즐을 풀려면 각 면에 있는 아홉 개의 작은 정육면체의 색이 동일해야 한다.

큐브는 각 면을 양방향으로 90도 만큼 돌릴 수 있도록 만들어져 있다. 회전이 마친 이후에는, 다른 면을 돌릴 수 있다. 이렇게 큐브의 서로 다른 면을 돌리다 보면, 색을 섞을 수 있다.

이 문제에서는 루빅스 큐브가 모두 풀린 상태에서 시작한다. 윗 면은 흰색, 아랫 면은 노란색, 앞 면은 빨간색, 뒷 면은 오렌지색, 왼쪽 면은 초록색, 오른쪽 면은 파란색이다.

루빅스 큐브를 돌린 방법이 순서대로 주어진다. 이때, 모두 돌린 다음에 가장 윗 면의 색상을 구하는 프로그램을 작성하시오.



위의 그림은 루빅스 큐브를 푼 그림이다. 왼쪽 면은 시계방향으로 조금 돌려져 있는 상태이다.

입력
첫째 줄에 테스트 케이스의 개수가 주어진다. 테스트 케이스는 최대 100개이다. 각 테스트 케이스는 다음과 같이 구성되어져 있다.

첫째 줄에 큐브를 돌린 횟수 n이 주어진다. (1 ≤ n ≤ 1000)
둘째 줄에는 큐브를 돌린 방법이 주어진다. 각 방법은 공백으로 구분되어져 있으며, 첫 번째 문자는 돌린 면이다. U: 윗 면, D: 아랫 면, F: 앞 면, B: 뒷 면, L: 왼쪽 면, R: 오른쪽 면이다. 두 번째 문자는 돌린 방향이다. +인 경우에는 시계 방향 (그 면을 바라봤을 때가 기준), -인 경우에는 반시계 방향이다.
출력
각 테스트 케이스에 대해서 큐브를 모두 돌린 후의 윗 면의 색상을 출력한다. 첫 번째 줄에는 뒷 면과 접하는 칸의 색을 출력하고, 두 번째, 세 번째 줄은 순서대로 출력하면 된다. 흰색은 w, 노란색은 y, 빨간색은 r, 오렌지색은 o, 초록색은 g, 파란색은 b.*/

package 삼성SW역량테스트기출;

import java.util.*;

public class N_5373 {
	static void left_cw(char[][][] A) {
		char[] temp = new char[3];
		// temp <- 앞
		temp[0] = A[2][0][0];
		temp[1] = A[2][1][0];
		temp[2] = A[2][2][0];
		// 앞 <- 위
		A[2][0][0] = A[0][0][0];
		A[2][1][0] = A[0][1][0];
		A[2][2][0] = A[0][2][0];

		// 위 <- 뒤
		A[0][0][0] = A[3][2][2];
		A[0][1][0] = A[3][1][2];
		A[0][2][0] = A[3][0][2];
		// 뒤<-아래
		A[3][0][2] = A[1][0][0];
		A[3][1][2] = A[1][1][0];
		A[3][2][2] = A[1][2][0];
		// 아래<-temp
		A[1][0][0] = temp[2];
		A[1][1][0] = temp[1];
		A[1][2][0] = temp[0];
		// 왼쪽 기준면도 돌아가는 사실!
		char a = A[4][0][0];
		A[4][0][0] = A[4][2][0];
		A[4][2][0] = A[4][2][2];
		A[4][2][2] = A[4][0][2];
		A[4][0][2] = a;
		a = A[4][0][1];
		A[4][0][1] = A[4][1][0];
		A[4][1][0] = A[4][2][1];
		A[4][2][1] = A[4][1][2];
		A[4][1][2] = a;
	}

	static void right_cw(char[][][] A) {
		char[] temp = new char[3];
		// temp<-위
		temp[0] = A[0][0][2];
		temp[1] = A[0][1][2];
		temp[2] = A[0][2][2];
		// 위<-앞
		A[0][0][2] = A[2][0][2];
		A[0][1][2] = A[2][1][2];
		A[0][2][2] = A[2][2][2];
		// 앞<-아래
		A[2][0][2] = A[1][2][2];
		A[2][1][2] = A[1][1][2];
		A[2][2][2] = A[1][0][2];
		// 아래<-뒤
		A[1][0][2] = A[3][0][0];
		A[1][1][2] = A[3][1][0];
		A[1][2][2] = A[3][2][0];
		// 뒤<-temp
		A[3][0][0] = temp[2];
		A[3][1][0] = temp[1];
		A[3][2][0] = temp[0];
		// 오른쪽 기준면도 돌아가는 사실!
		char a = A[5][0][0];
		A[5][0][0] = A[5][2][0];
		A[5][2][0] = A[5][2][2];
		A[5][2][2] = A[5][0][2];
		A[5][0][2] = a;
		a = A[4][0][1];
		A[5][0][1] = A[5][1][0];
		A[5][1][0] = A[5][2][1];
		A[5][2][1] = A[5][1][2];
		A[5][1][2] = a;
	}

	static void up_cw(char[][][] A) {
		char[] temp = new char[3];
		// temp<-왼
		temp[0] = A[4][0][0];
		temp[1] = A[4][0][1];
		temp[2] = A[4][0][2];
		// 왼<-앞
		A[4][0][0] = A[2][0][0];
		A[4][0][1] = A[2][0][1];
		A[4][0][2] = A[2][0][2];
		// 앞<-오
		A[2][0][0] = A[5][0][0];
		A[2][0][1] = A[5][0][1];
		A[2][0][2] = A[5][0][2];
		// 오<-뒤
		A[5][0][0] = A[3][0][0];
		A[5][0][1] = A[3][0][1];
		A[5][0][2] = A[3][0][2];
		// 뒤<-temp
		A[3][0][0] = temp[0];
		A[3][0][1] = temp[1];
		A[3][0][2] = temp[2];
		// 위쪽 기준면도 돌아가는 사실!
		char a = A[0][0][0];
		A[0][0][0] = A[0][2][0];
		A[0][2][0] = A[0][2][2];
		A[0][2][2] = A[0][0][2];
		A[0][0][2] = a;
		a = A[0][0][1];
		A[0][0][1] = A[0][1][0];
		A[0][1][0] = A[0][2][1];
		A[0][2][1] = A[0][1][2];
		A[0][1][2] = a;
	}

	static void down_cw(char[][][] A) {
		char[] temp = new char[3];
		// temp<-오
		temp[0] = A[5][2][0];
		temp[1] = A[5][2][1];
		temp[2] = A[5][2][2];
		// 오<-앞
		A[5][2][0] = A[2][2][0];
		A[5][2][1] = A[2][2][1];
		A[5][2][2] = A[2][2][2];
		// 앞<-왼
		A[2][2][0] = A[4][2][0];
		A[2][2][1] = A[4][2][1];
		A[2][2][2] = A[4][2][2];
		// 왼<-뒤
		A[4][2][0] = A[3][2][0];
		A[4][2][1] = A[3][2][1];
		A[4][2][2] = A[3][2][2];
		// 뒤<-temp
		A[3][2][0] = temp[0];
		A[3][2][1] = temp[1];
		A[3][2][2] = temp[2];
		// 아래쪽 기준면도 돌아가는 사실!
		char a = A[1][0][0];
		A[1][0][0] = A[1][2][0];
		A[1][2][0] = A[1][2][2];
		A[1][2][2] = A[1][0][2];
		A[1][0][2] = a;
		a = A[1][0][1];
		A[1][0][1] = A[1][1][0];
		A[1][1][0] = A[1][2][1];
		A[1][2][1] = A[1][1][2];
		A[1][1][2] = a;
	}

	static void front_cw(char[][][] A) {
		char[] temp = new char[3];
		// temp<-오
		temp[0] = A[5][0][0];
		temp[1] = A[5][1][0];
		temp[2] = A[5][2][0];
		// 오<-위
		A[5][0][0] = A[0][2][0];
		A[5][1][0] = A[0][2][1];
		A[5][2][0] = A[0][2][2];
		// 위<-왼
		A[0][2][0] = A[4][2][2];
		A[0][2][1] = A[4][1][2];
		A[0][2][2] = A[4][0][2];
		// 왼<-아래
		A[4][2][2] = A[1][2][2];
		A[4][1][2] = A[1][2][1];
		A[4][0][2] = A[1][2][0];
		// 아래<-temp
		A[1][2][2] = temp[0];
		A[1][2][1] = temp[1];
		A[1][2][0] = temp[2];
		// 앞쪽 기준면도 돌아가는 사실!
		char a = A[2][0][0];
		A[2][0][0] = A[2][2][0];
		A[2][2][0] = A[2][2][2];
		A[2][2][2] = A[2][0][2];
		A[2][0][2] = a;
		a = A[2][0][1];
		A[2][0][1] = A[2][1][0];
		A[2][1][0] = A[2][2][1];
		A[2][2][1] = A[2][1][2];
		A[2][1][2] = a;
	}

	static void back_cw(char[][][] A) {
		char[] temp = new char[3];
		// temp<-왼
		temp[0] = A[4][0][0];
		temp[1] = A[4][1][0];
		temp[2] = A[4][2][0];
		// 왼<-위
		A[4][0][0] = A[0][0][2];
		A[4][1][0] = A[0][0][1];
		A[4][2][0] = A[0][0][0];
		// 위<-오
		A[0][0][2] = A[5][2][2];
		A[0][0][1] = A[5][1][2];
		A[0][0][0] = A[5][0][2];
		// 오<-아래
		A[5][2][2] = A[1][0][0];
		A[5][1][2] = A[1][0][1];
		A[5][0][2] = A[1][0][2];
		// 아래<-temp
		A[1][0][0] = temp[0];
		A[1][0][1] = temp[1];
		A[1][0][2] = temp[2];
		// 뒤쪽 기준면도 돌아가는 사실!
		char a = A[3][0][0];
		A[3][0][0] = A[3][2][0];
		A[3][2][0] = A[3][2][2];
		A[3][2][2] = A[3][0][2];
		A[3][0][2] = a;
		a = A[3][0][1];
		A[3][0][1] = A[3][1][0];
		A[3][1][0] = A[3][2][1];
		A[3][2][1] = A[3][1][2];
		A[3][1][2] = a;
	}

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner s = new Scanner(System.in);
		int T = s.nextInt();
		for (int i = 0; i < T; i++) {
			int n = s.nextInt();
			char[][][] A = new char[6][][]; // 큐브 초기화
			for (int k = 0; k < A.length; k++) {
				A[k] = new char[3][3];
				for (int w = 0; w < 3; w++) {
					for (int z = 0; z < 3; z++) {
						if (k == 0)
							A[k][w][z] = 'w';
						else if (k == 1)
							A[k][w][z] = 'y';
						else if (k == 2)
							A[k][w][z] = 'r';
						else if (k == 3)
							A[k][w][z] = 'o';
						else if (k == 4)
							A[k][w][z] = 'g';
						else
							A[k][w][z] = 'b';
					}
				}
			}
			for (int j = 0; j < n; j++) {
				String str = s.next();
				if (str.equals("L+")) {
					left_cw(A);
				} else if (str.equals("L-")) {
					left_cw(A);
					left_cw(A);
					left_cw(A);

				} else if (str.equals("R+")) {
					right_cw(A);
				} else if (str.equals("R-")) {
					right_cw(A);
					right_cw(A);
					right_cw(A);
				} else if (str.equals("U+")) {
					up_cw(A);
				} else if (str.equals("U-")) {
					up_cw(A);
					up_cw(A);
					up_cw(A);
				} else if (str.equals("D+")) {
					down_cw(A);
				} else if (str.equals("D-")) {
					down_cw(A);
					down_cw(A);
					down_cw(A);
				} else if (str.equals("F+")) {
					front_cw(A);
				} else if (str.equals("F-")) {
					front_cw(A);
					front_cw(A);
					front_cw(A);
				} else if (str.equals("B+")) {
					back_cw(A);
				} else if (str.equals("B-")) {
					back_cw(A);
					back_cw(A);
					back_cw(A);
				}
			}

			for (int j = 0; j < 3; j++) {
				for (int k = 0; k < 3; k++)
					System.out.print(A[0][j][k]);
				System.out.println();
			}

		}
	}

}
